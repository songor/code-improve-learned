# 代码精进之路

### 开篇词 | 你写的每一行代码，都是你的名片

每一行代码，都体现着程序员的修为，思考问题的深度，甚至是处理问题的习惯和态度。

作为一名软件工程师，我们该怎么快速成长，并且保持长久的竞争力？

解决这个问题的终极方法，只有一个，那就是**持续地交付优秀的结果**。

### 01 | 从条件运算符说起，反思什么是好代码

坚持使用最直观的编码方式，而不是追求代码简短，真的可以避免很多不必要的错误。

关于优秀代码的特点，我想用**“经济”**这一个词语来表达。这里的“经济”，指的是使用较少的人力、物力、财力、时间、空间来获取较大的成果或收益。或者简单地说，投入少、收益大、投资回报高。

该怎么理解“经济”呢？这需要我们把代码放到软件的整个生命周期里来考察。

### 02 | 把错误关在笼子里的五道关卡

```c
    if ((error = doSomething()) != 0)
        goto fail;   
        goto fail;  
    if ((error= doMore()) != 0)  
        goto fail;
fail:  
    return error;
```

第一道关：程序员

提高程序员的修养，是一个永不过时的课题。从别人的失败和自己的失败中学习、积累、提高，是一个程序员成长的必修课。

首先，他应该正确使用缩进。其次，他应该使用大括号。

优秀的代码源于我们对细节的热情和执着。

第二道关：编译器

对于编译器的警告，我们一定要非常警觉。能消除掉所有的警告，你就应该消除掉所有的警告。就算实在没有办法消除掉编译警告，那你也一定要搞清楚警告产生的原因，并确认编译警告不会产生任何后续问题。

第三道关：回归测试

一般地，软件测试会尽可能地覆盖关键逻辑和负面清单，以确保关键功能能够正确执行，关键错误能够有效处理。

另外，这些测试代码还有一个关键用途就是做回归测试。如果有代码变更，我们可以用回归测试来检查代码变更有没有使代码变得更坏。

第四道关：代码评审

代码评审是一个有效的在软件研发过程中抵御人类缺陷的制度。通过更多的眼睛检查软件代码，被忽视的错误更容易被逮住，更好的设计和实现更容易浮现出来。

第五道关：代码分析

静态代码分析（Static Code Analysis）是通过对源代码的检查来发现潜在问题的一种软件质量保障方式。

代码覆盖率（Code Coverage）是一个反映测试覆盖程度的指标。它不仅仅量化测试的指标，也是一个检测代码缺陷的好工具。

**代码制造的流水线**

编写优秀的代码，不能仅仅依靠一个人的战斗。代码的优秀级别，依赖于每个关卡的优秀级别。高质量的代码，依赖于高质量的流水线。每道关卡都应该给程序员提供积极的反馈，这些反馈，在保障代码质量的同时，也能帮助程序员快速学习和成长。

### 03 | 优秀程序员的六个关键特质

**掌握一门编程语言**

对于编程语言，我们了解得越多，熟知的招式就越多，可选择的范围就越大，我们就有更多的活动空间和解决问题的办法。

**解决现实的问题**

只有理解了问题，看到了解决问题的价值，我们才能够真正解决好问题，并且从中获得满满的成就感。我们一定要记得，程序员的存在不是为了写代码，而是为了解决现实问题，实现现实价值。

如果说花样的工具是外家功夫，思维能力和行为能力可以算是内功。

优秀的程序员，是一个内外双修的程序员。如果一个程序员可以熟练使用工具，有清晰的解决问题思路，能明晰地传达产品价值，那么他编写代码就不存在什么巨大的困难了。

**发现关键的问题**

优秀的程序员，能够发现一门编程语言的缺陷，一个顺手工具的局限。所以，他知道该怎么选择最合适的工具，该怎么避免不必要的麻烦。

优秀的程序员，能够发现解决方案背后的妥协和风险。所以，他可以预设风险防范措施，设置软件的适用边界。

优秀的程序员，能够敏锐地观察到产品的关键问题，或者客户未被满足的需求。所以，他可以推动产品持续地进步和演化。

能够发现关键的问题，意味着我们可以从一个被动做事情的程序员，升级为一个主动找事情的程序员。

能够发现关键的问题，往往需要我们对一个领域有很深入的研究和深厚的积累，并且对新鲜事物保持充分的好奇心和求知欲。

**沉静的前行者**

优秀的程序员，一定是懂得妥协，懂得选择，一步一步把事情沉静地朝前推动的人。

对完美的过分追求，可能是一个代价高昂，收获甚小的行为。

而且，完美也可能意味着不承认缺陷，不承认未知。这样，我们可能在心理上就不会对代码的未知风险做出充分的预判，留出足够的安全缓冲空间。

**可以依赖的伙伴**

优秀的程序员，知道团队合作的重要性，是一个优秀的团队成员。

如果说，编程语言、花样工具、逻辑思维、解决问题这些“硬技能”可以决定我们的起点的话，影响力、人际关系这些“软技能”通常影响着我们可以到达的高度。

**时间管理者**

坚持把时间用在对的地方，用在价值更大的地方。

要做只有你才能做的事情。

要坚持做需要做的事情。不需要的、不紧急的、价值不大的我们可以暂时搁置起来。一个人能做的事情是有限的，能把最重要的事情最好，就已经很了不起了。

### 04 | 代码规范的价值：复盘苹果公司的 GoToFail 漏洞

**什么是编码规范？**

编码规范指的是针对特定编程语言约定的一系列规则，通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等。

编码规范可以帮我们选择编码风格、确定编码方法，以便更好地进行编码实践。简单地说，一旦学会了编码规范，并且严格地遵守它们，可以让我们的工作更简单，更轻松，少犯错误。

**规范的代码，可以降低代码出错的几率**

复杂是代码质量的敌人。越复杂的代码，越容易出现问题，并且由于复杂性，我们很难发现这些隐藏的问题。

所以在编码的时候，我们应该尽量使代码风格直观、逻辑简单、表述直接。

**规范的代码，可以提高编码的效率**

在代码制造的每一道关卡，规范执行得越早，问题解决得越早，整个流水线的效率也就越高。

**规范的代码，降低软件维护成本**

在一个软件生命周期里，软件维护阶段花费了大约 80% 的成本。

代码问题修改的过程包含了很多角色：代码的编写者、代码的使用者、问题的审阅者以及问题的解决者，这些角色一般不是同一个人。在修改代码时，不管我们是其中的哪一个角色，遵守规范的代码都能够节省我们的时间。

很多软件代码，其生命的旅程超越了它的创造者，超越了团队的界限，超越了组织的界限，甚至会进入我们难以预想的领域。

严格遵守共同的编码规范，提高代码的可读性，可以使参与其中的人更容易地理解代码，更快速地理解代码，更快速地解决问题。

**编码规范越使用越高效**

如果我们像乘法表一样熟练使用编码规范，一旦遇到没有使用大括号的语句，我们就会非常警觉。因为，不使用大括号的编码方式不符合我们习以为常的惯例，快系统立即就能判别出异常状况，然后交给慢系统做进一步的思考。

所以，我们要尽早地使用编码规范，尽快地培养对代码风格的敏感度。

优秀的代码不光是给自己看的，也是给别人看的，而且首先是给别人看的。

### 05 | 经验总结：如何给你的代码起好名字？

**为什么需要一个好名字？**

名字要准确地代表它背后的东西，并且还能让代码干净漂亮。

名字就是沟通的方式，错误的命名很难让我们清楚地理解代码真实的意图。所以，混淆的命名很难让我们阅读和理解代码。

**为什么需要命名规范？**

使代码审核变得更有效率，专注于更重要的问题，而不是争论语法和命名规范这类小细节；

提高代码的清晰度、可读性以及美观程度；

**有哪些常见的命名方法？**

*驼峰命名法*

驼峰命名法指的是使用大小写混合的格式，单词之间不使用空格隔开或者连接字符连接的命名方式。

Google 定义了以下的转换规则：

从正常的表达形式开始，把短语转换成 ASCII 码，并且移除单引号。

如果上述结果含有其他标点符号（比如连字符），在该符号处把这个结果切分成单词形式。如果某个单词已经是驼峰形式，也相应地切分开来。

将所有字母转换为小写字母，然后将每个单词的首字母大写，这样就得到了大驼峰式命名的形式；如果第一个单词的首字母小写，就得到了小驼峰式命名的形式。

将所有的单词连在一起，就是最后的标识符命名。

| 短语                 | 正确的转换形式    | 错误的转换形式    |
| -------------------- | ----------------- | ----------------- |
| XML HTTP request     | XmlHttpRequest    | XMLHTTPRequest    |
| new customer ID      | newCustomerId     | newCustomerID     |
| inner stopwatch      | innerStopwatch    | innerStopWatch    |
| supports IPv6 on iOS | supportsIpv6OnIos | supportsIPv6OnIOS |

*蛇形命名法*

单词之间通过下划线“_”连接。

*串式命名法*

单词之间通过连字符“-”连接。

*匈牙利命名法*

标识符由一个或者多个小写字母开始，这些字母用来标识标识符的类型（系统匈牙利命名法）或者用途（应用匈牙利命名法）。标识符的剩余部分，可以采取其他形式的命名法。

**Java 命名规范**

| 标识符类型        | 适用命名方法                                                                   |
| ----------------- | ------------------------------------------------------------------------------ |
| package           | 使用名词；包名全部小写；不能使用连接符；尽量使用单个名词作为包名。             |
| class / interface | 使用名词或者名词短语，接口也可以使用形容词；大驼峰命名法；尽量避免使用缩略语。 |
| 方法              | 通常使用动词或者动词短语；小驼峰命名法；尽量避免使用缩略语。                   |
| 变量              | 小驼峰命名法，尽量避免使用单个字符命名（用完即扔的少数特例除外）               |
| 常量              | 蛇形命名法；使用大写字母。                                                     |

**怎么取好名字？**

*要有准确的意义*

*严格遵守命名规范*

*可读性优先*

可读性强的名字优先于简短的名字，尽量使用完整的词汇；

不要使用缩写、简写、缩略词，除非这些词语被广泛使用；

不要使用太短的名字，比如一个字母，除非是广泛接受的特例；

避免含糊、混淆或者误导；

不要混合使用英文和汉语拼音。

“信、达、雅”（准确、直观、优美）

### 06 | 代码整理的关键逻辑和最佳案例

把代码分割成大脑能够有效识别并记忆的信息块，通过合理地使用空行、空格和缩进，把这些信息块清晰地呈现出来。

**给代码分块**

保持代码块的单一性，一个代码块只能有一个目标。

注意代码块的完整性。一个代码块要表达一个相对完整的意思，不能一个意思没说完就分块了。

代码块数量要适当。一个基础的代码块最好不要超过 25 行。

**使用空白空间**

靠近的代码会形成一个视觉块，并且具有隐含的关联。分开的代码，意味着上下两段代码的关联没有那么紧密。

*同级别代码块靠左对齐*

*同级别代码块空行分割*

*下一级代码块向右缩进*

由于我们倾向于使用有准确意义的命名，标识符的长度往往是一个不能忽视的因素。现在的编码规范，四个空格的缩进最为常见，二个空格的缩进次之，八个空格的缩进使用的较少。

*同行内代码块空格区隔*

**一行一个行为**

一般一个完整的表达式可以看作是一个独立的行为。

**基本的换行原则**

每行代码字符数的限制。一般情况下，每行代码不要超出 80 个字符（80 个字符是传统终端的宽度，比如 vi 编译器）。由于屏幕尺寸和代码阅读终端的变化，现在的很多规范开始使用 120 个字符的限制。

如果一行不足以容纳一个表达式，就需要换行。

在逗号后换行；

在操作符前换行；

高级别的换行优先；尽量把同一优先级的表达式保留在同一行，和低级别的区别开来。

```java
// conventional indentation
int runningMiles = runningSpeedOne * runningTimeOne
                 + runningSpeedTwo * runningTimeTwo;

// confusing indentation
int runningMiles = runningSpeedOne
       * runningTimeOne + runningSpeedTwo
       * runningTimeTwo;
```

新的换行与上一行同级别表达式的开头对齐；

如果上述规则导致代码混乱或者代码太靠右，使用 8 个空格作为缩进（两个缩进单位）。

```java
// bad indentation
if ((conditionOne && conditionTwo)
    || (conditionThree && conditionFour)) {
    doSomething();  
}

// a better indentation, using 8 spaces for the indentation
if ((conditionOne && conditionTwo)
        || (conditionThree && conditionFour)) {
    doSomething();  
}
```

### 07 | 写好注释，真的是小菜一碟吗？

注释是用来提高代码的可读性和可维护性的。不要让注释偏离了这个原则，破坏了代码的逻辑和可读性。

Code Tells You How, Comments Tell You Why.

**注释是无奈的妥协**

正如一个作家无法预料他的读者能否清晰地理解他的文字一样，一个程序员也不能判断他的读者能否清晰地理解他写的代码。

因为注释不需要运行，所以没有常规的办法来测试它。注释难以维护，这是使用注释带来的最大的麻烦。

注释为我们提供了一个借口。我们有时候会过度依赖解释，从而放弃了潜在的替代方案，比如更准确的命名，更清晰的结构，更顺畅的逻辑等等。

注释的滥用。由于注释部分不被执行，那么就可以被用来注释掉一些不需要的东西。

总结一下，注释是代码的一部分，是需要阅读的内容，目的是让其他人能更好地理解我们的代码，写注释需要我们有“用户思维”。

**几种常见注释类型**

**第一种类型，是记录源代码版权和授权的**，一般放在每一个源文件的开头，说明源代码的版权所有者，以及授权使用的许可方式，或者其他的公共信息。

**第二种类型，是用来生成用户文档的**，比如 Java Doc。这些文档帮助使用者了解软件的功能和细节，主要面向的是该软件的使用者，而不是该软件的开发者。

**第三种类型，是用来解释源代码的**。换句话说，就是帮助代码的阅读者理解代码。

**简化注释的风格**

针对第一种注释类型，也就是固定的版权和授权信息，使用一般的星号注释符。

```java
/*
 * Copyright (c) 2022, Song Yu Chen. All rights reserved.
 */
```

针对第二种注释类型，即生成用户文档的注释，使用 Javadoc 要求的格式，文档注释符。

```java
/**
 * A {@code Readable} is a source of characters. Characters from
 * a {@code Readable} are made available to callers of the read
 * method via a {@link java.nio.CharBuffer CharBuffer}.
 *
 * @since 1.5
 */
public interface Readable {
    ...
}
```

针对第三种注释类型，也就是代码解释注释，只使用行注释符。

```java
// Verify that the buffer has sufficient remaining
private static void verifyLength(
        ByteBuffer buffer, int requiredLength) {
    ...
}

String myString;  // using end-to-line comment

// This is a multiple line comment.  This is a multiple
// line comment. 
if (!myString.isEmpty()) {
    ...
}
```

如果一段代码不再需要，我会清理掉代码，而不会保留这个注释掉的代码块。不要在源代码里记录代码历史，那是代码版本管理系统该干的事情。

**注释的三项原则**

**准确**，错误的注释比没有注释更糟糕。

**必要**，多余的注释浪费阅读者的时间。

**清晰**，混乱的注释会把代码搞得更乱。如果注释和代码不能从视觉上清晰地分割，注释就会破坏代码的可读性。

另外，不要在代码里标注你想要做的工作和已经做过的工作。比如使用 TODO，记录代码更改记录等等。

特别需要注意的是，我们可以使用临时的调试语句，但是，不要把代码的调试语句保留在提交的代码里。

### 08 | 写好声明的“八项纪律”

在 Java 语言里，声明可以用来定义类、方法、类变量、局部变量和常量。

**取一个好名字**

**一行一个声明**

需要注意的是，表示数组的中括号 [] 是类型的一部分，而不是标识符的一部分。

```java
// 反面案例
int entries[];
// 正面案例
int[] entries;
```

**局部变量需要时再声明**

**类属性要集中声明**

**声明时就初始化**

除非变量的初始值依赖于更多的条件，或者涉及到一定的计算，否则，声明时就应该完成初始化。

**尾随的花括号**

左括号不要单独成行，要紧随在语句尾部，以一个空格隔开；右括号单独一行。

**靠紧的小括号**

**搜索优化的换行**

常见的搜索模式有：

“public class”

“abstract class”

“class TheClassName”

“extends TheClassName”

“implements TheInterfaceName”

“theMethodName(”

语义相关的词语，常见的搜索模式，要尽量放在同一行。

### 09 | 怎么用好 Java 注解？

Override / Deprecated / SuppressWarnings

**在声明继承关系中，Java 注解该如何使用？**

第一个麻烦是，识别子类的方法是不是重写方法。

如果一个方法是重写方法，一定要使用 Override 注解，清楚地标明这个方法是重写的方法。

第二个麻烦是，重写方法可以不遵守父类方法的规范。

一般来说，一个重写方法不应该改变父类定义的规范。如果的确需要改变，就要有充足的理由，以及面对潜在兼容问题的解决办法。

如果重写方法既没有改变父类规范，也没有其他情况需要重点说明，重写方法就不应该有规范描述部分的存在。

```java
// 重写方法严格遵守父类定义的规范
class Student extends Person {
    @Override
    public String getFirstName() {
        // snipped
    }
}
```

```java
// 重写方法改写了父类定义的规范
class Student extends Person {
    /**
     * Get the first name of the student.
     *
     * Note that the returned value may be null if ...
     */
    @Override
    public String getFirstName() {
        // snipped
        return null;
    }
}
```

**在废弃退役接口的情况下，如何使用注解？**

第一件事情是，如果接口的设计存在不合理性，或者新方法取代了旧方法，我们应该尽早地废弃该接口。

对于代码而言，要在声明中使用 Deprecated 注解；在规范描述中，说明废弃的原因以及替代的办法；对于有计划要删除的接口，注明计划删除的版本号。

第二件事情是，如果我们在现有的代码中使用了废弃的接口，要尽快转换、使用替换的方法。

### 10 | 异常处理都有哪些陷阱？

**异常就是非正常**

不应该使用异常机制来处理正常的状况。

如果 userName 字符串不符合规范，这是一个异常状况；如果 userName 不是一个注册用户，这通常是一个正常状况。 在正常状况下使用异常处理，无疑会降低系统的效率。

```java
/**
 * Check if the user name is registered.
 *
 * @return true if the user name is registered.
 * @throws IllegalArgumentException if the user name is invalid.
 */
boolean isRegisteredUser(String userName) {
    // snipped
}
```

**分清异常的类别**

*非正常异常（Error）、错误*

这类异常的命名通常以 Error 结尾，比如 OutOfMemoryError，NoSuchMethodError。编译器编译时不检查，应用程序不需要处理，接口不需要声明，接口规范也不需要纪录。

*运行时异常（RuntimeException）、非检查型异常（UncheckedException）*

这类异常的命名通常以 Exception 结尾，比如 IllegalArgumentException，NullPointerException。编译器编译时不检查，接口不需要声明，但是应用程序可能需要处理，因此**接口规范需要记录清楚**。

*非运行时异常、检查型异常（CheckedException）*

和运行时异常一样，命名通常以 Exception 结尾。编译器编译时会检查异常是否已经处理或者可以抛出，接口需要声明，应用程序需要处理，接口规范需要记录清楚。

**标记清楚抛出异常**

目前我们使用的编译器或者 IDE，还没有提醒**运行时异常**遗漏的功能。

对于所有可能抛出的运行时异常，都要有清晰的描述，一个也不要错过；查看所有调用方法的规范描述，确认抛出的异常要么已经处理，要么已经规范描述。

**处理好捕获异常**

Java 异常的四个要素：异常类名、异常描述、异常堆栈、异常转换（Caused by: xxx）。

异常类名解决了“出了什么错”的问题；异常描述解决了“为什么会出错”的问题；异常堆栈解决了“什么地方出了错”的问题。

*对于异常类名，我们要准确地选择异常类*

除非是超级接口，否则我们应该尽量减少超级异常类（Exception、RuntimeException、IOException 等）的使用，而是选择那些意义明确、覆盖面小的异常类。

*对于异常描述，我们要清晰地描述异常信息*

*对于异常转换，我们要恰当地转换异常场景*

用户关心的是商业的逻辑，并不是实现的细节，这就需要我们随着使用场景调整异常。

随着场景调整异常也不是没有代价的：

需要编写转换的代码。

信息的冗余。如果转换场景有两三层，打印出来的堆栈信息就会很长，而最有用的信息只是最原始的异常。

信息的丢失。有些信息的丢失是有意的，比如对敏感信息的过滤而丢掉的异常信息。有些信息的丢失是无意的过失。信息的丢失很难让我们排查出异常问题，于是错误的源头被硬生生地隐匿了起来。

```java
// 反面案例
try {
    // snipped
} catch (IllegalFormatException e) {
    // 丢失了源异常信息
    throw new MyException("illegal user name");
}

// 正面案例
try {
    // snipped
} catch (IllegalFormatException e) {
    throw new MyException("illegal user name", e);
}
```

### 11 | 组织好代码段，让人对它“一见钟情”

如果我们看到整齐、清爽的代码，我们就对它有好感，愿意阅读，也愿意改进。如果代码一团糟，风格混乱，我们就特别想静静地走开，一行都不想看。

**代码文件头部结构**

版权和许可声明；命名空间（package）；外部依赖（import）。

**代码文件对象结构**

类的规范；类的声明；类的属性和方法。

对于公共类，需要使用 since 标签，标明从哪一个版本开始定义了这个类。

**类的内部代码结构**

类的属性；构造方法；工厂方法；其他方法。

**方法的代码结构**

方法的规范；方法的声明；方法的实现。

一个典型的规范，应该包含以下十个部分：

方法的简短介绍；

方法的详细介绍（可选项）；

规范的注意事项（使用 apiNote 标签，可选项）；

实现方法的要求（使用 implSpec 标签，可选项）；

实现的注意事项（使用 implNote 标签，可选项）；

方法参数的描述；

返回值的描述；

抛出异常的描述：需要注意的是，抛出异常的描述部分，不仅要描述检查型异常，还要描述运行时异常；

参考接口索引（可选项）；

创始版本（可选项）。

**按顺序使用限定词**

public / private / protected（访问控制限定词，制定访问权限）

abstract（抽象类或者抽象方法，具体实现由子类完成）

static（静态类、方法或者类属性）

final（定义不能被修改的类、方法或者类属性）

transient（定义不能被序列化的类属性）

volatile（定义使用主内存的变量）

default（声明缺省的方法）

synchronized（声明同步的方法）

native（声明本地的方法，也就是 Java 以外的语言实现的方法）

strictfp（声明使用精确浮点运算）

**使用空行分割代码块**

版权和许可声明代码块；

命名空间代码块；

外部依赖代码块类的代码块；

类的属性与方法之间；

类的方法之间；

方法实现的信息块之间。

### 12 | 组织好代码文件，要有“用户思维”

**逻辑之一：软件是干什么的？**

可以回答这个问题的文件叫做 README，它的命名全部使用大写字母。需要被放在一个软件工程的根目录里，方便人或者机器第一时间找到，从而轻而易举地找到并进行阅读。

**逻辑之二：软件可以拿来用吗？**

所有的软件，都有归属，都受版权的保护。

版权描述一般放在每一个源文件的头部。不同的源文件可以有不同的版权，同一个源文件也可以有一个以上的版权所有者。

如果版权来源只有一个，而且源文件头部没有版权描述，我们就需要把版权描述放到最显眼的地方。这个地方就是软件工程的根目录，命名为 COPYRIGHT，全部使用大写字母。

有了版权保护，不代表我们就不能使用这个软件了。我们能不能使用、怎么使用，是由软件的许可证确定的。

许可证文件是 LICENSE，全部使用大写字母，放在软件工程项目的根目录下。

当使用软件的时候，不能超越许可证约定的范围。

**逻辑之三：软件是怎么实现的？**

通常来说，源代码存放在根目录下的 src 目录下。

每一个命名空间的节点，都要对应一个文件目录。

**逻辑之四：软件该怎么测试？**

通常来说，源代码存放在根目录下的 test 目录下。

一个测试文件，最好执行一个独立的任务。如果测试出错误，我们就能够快速定位错误。这也要求测试的目标要小，测试的结果要清晰，测试的组织要照应功能代码的组织。

**软件该怎么使用？**

一个好的软件，要尽可能降低使用门槛。编写使用指南和代码示例是两个常用的办法。一份好的用户文档，应该让软件的用户快速入门，然后再逐步深入地了解整个软件的使用细节，以及潜在的问题。

在根目录下，有一个名字为 docs 或者 doc 的目录。这个目录就是存放软件文档的。

对于每一行的代码变更，我们都要问，需不需要文档变更？如果代码和文档一致的话，就会节省我们大量的维护时间和维护成本。

### 13 | 接口规范，是协作的合约

**区分外部接口和内部实现**

外部接口，就是协作的界面，要简单规矩；内部实现，可以是千变万化的复杂小世界。

提高协作效率的最高技巧不是提高沟通技巧，而是要减少沟通的数量，提高沟通的质量，尤其是要减少数量。

**接口规范是协作合约**

*合约要成文*

如果调用者需要去看实现代码来理解外部接口，那么外部接口和内部实现的分离还有什么用呢？不就背离了外部接口和内部实现分离的初衷吗？

*合约要清楚*

接口规范主要用来描述接口的设计和功能，包括确认边界条件、指定参数范围以及描述极端状况。

这里需要注意的是，接口规范不是我们定义术语、交代概念、提供示例的地方。

*合约要稳定*

*变更要谨慎*

**使用 Java Doc**

它通过文档注释的形式，在接口声明的源代码定义和描述接口规范。这种和源代码结合的方式，可以方便我们维护接口规范，也有利于保持接口规范和接口声明的一致性。

如果有两种以上不同形式的规范组织文档，我建议一定要互相链接、引用。

**谁来制定接口合约？**

既然是合约，就是大家都认可并且接受的规范和细节，只有形成共识才能编辑和修订。合约的编写和修订，一般不应该由源代码的维护者一人决定，而应该由参与各方充分沟通和协商。

### 14 | 怎么写好用户指南？

最好的用户指南，是产品本身。然而，不是所有的产品都能够简单到拿来就用。一份合格的用户指南，要帮助用户减少产品使用的障碍，快速地使用产品。

**谁是指南的用户？（用户指南写给谁？）**

一般来说，我们把用户的门槛降得越低，潜在用户的群体就越大，软件就越容易推广。

我们不能想当然地认为，有了详实的用户指南，用户就能够使用产品。

事实上，用户指南，不能超越用户的理解能力和操作能力。

**什么时候确定产品用户？**

在产品设计时，就需要解决掉用户定位和怎么使用这两个问题。

**保持指南和代码的一致**

源代码修改和用户指南的修改，一定要放在一个连贯的流程里。

可以像 OpenJDK 一样，通过改进开发流程，把用户指南修改和代码变更绑定在一起。用户指南修改完成，这个代码变更才算完成。

**开发指南的实践**

它的典型用户是使用该软件 API 的软件工程师。

开发指南的重点在于定义术语、交代概念、提供示例、问题排查等。

接口规范描述的是每一个部件的规格，是一个细节、局部的范围。开发指南说的就是怎么理解这些部件之间的关系，怎么把这些部件组合起来，形成更大的部件或者产品。

*交代概念*

一个合格的开发指南，不要假定用户具有和开发者一样的知识范围。对应的接口规范和开发指南里涉及到的概念，一定要交代清楚。

交代清楚概念，很方便作者和读者之间建立共识，降低后续文档的阅读负担。

*快速上手*

一个好的开发指南，要尽最大可能，让开发者快速上手。

*示例都可操作*

可操作性是开发指南的一个命门。所有成文的方法和示例，都要求可以使用、可以操作、可以验证。

开发指南，需要适应版本的变迁和代码的修改。

### 15 | 编写规范代码的检查清单

**标准与指南**

标准是既定的做事方式，它定义了一个事物如何始终如一地达到同样水准的细节。标准的特征在于，它既是必需的，也是强制的。

然而，在现实实践中，能够标准化的东西是有限的。

指南告诉我们应该采取的总体方向和最佳实践，它是一个指导原则，是建议，不强制执行。

我们所说的编码规范，实际上通常是指导原则。虽然不具备强制性，但我们也有必要区分对不同建议条款的态度。

**为什么需要编码规范？**

提高编码的效率 / 提高编码的质量 / 降低维护的成本 / 扩大代码的影响

**编码规范的心理因素**

*两种思维模式*

自主模式（快系统）的运行是无意识的、快速的、不怎么耗费脑力；控制模式（慢系统）需要集中注意力，耗费脑力，判断缓慢，如果注意力分散，思考就会中断。

编码规范中很大一部分内容，是增加共识、减少意外，扩大自主思维模式覆盖的范围，减少控制模式必须参与的内容。

*识别模式*

它可以帮助我们毫不费力地使用经验，但习惯一旦养成就很难改变，我们不愿意打破旧模式，去学习新模式和接受新技术。

程序员很容易理解和自己编码风格类似的代码。如果编码风格和自己的大相径庭，就会感到焦躁和烦恼。

*猜测模式*

对于既定模式的识别，是通过猜测进行的。

在编写代码时，我们要有意识地提供足够的线索和背景，使用清晰的结构，加快模式的识别，避免造成模式匹配过程中的模糊和混淆带来的理解障碍。

*记忆模式*

我们的记忆模式有四种，包括感官、短期、工作和长期记忆。

我们在组织代码时，不要让短期记忆超载，要使用短小的信息快，方便阅读；要适当分割需要长期记忆和短期记忆的内容，比如接口规范和代码实现，帮助读者在工作记忆和长期记忆中组织和归档信息。

*眼睛的运动*

有时候，我们需要反复研读一段代码。如果这段代码可以在一个页面显示，我们的眼睛就很容易反复移动，寻找需要聚焦的目标。如果这段代码跨几个页面，阅读分析就要费力得多。

在编码排版时，要清晰分块，保持布局明朗，限制每行的长度，这样可以方便眼睛的聚焦和浏览。

**编码规范的检查清单**

代码是按照编码指南编写的吗？

代码能够按照预期工作吗？

文件是不是在合适的位置？

支撑文档是不是充分？

代码是不是易于阅读、易于理解？

代码是不是易于测试和调试？

有没有充分的测试，覆盖关键的逻辑和负面清单？

名字是否遵守命名规范？

名字是不是拼写正确、简单易懂？

名字是不是有准确的意义？

代码的分块是否恰当？

代码的缩进是否清晰、整洁？

有没有代码超出了每行字数的限制？

代码的换行有没有引起混淆？

每一行代码是不是只有一个行为？

变量的声明是不是容易检索和识别？

变量的初始化有没有遗漏？

括号的使用是不是一致、清晰？

源代码的组织结构是不是一致？

版权信息的日期有没有变更成最近修改日期？

限定词的使用是不是遵循既定的顺序？

有没有注释掉的代码？

有没有执行不到的代码？

有没有可以复用的冗余代码？

复杂的表达式能不能拆解成简单的代码块？

代码有没有充分的注释？

注释是不是准确、必要、清晰？

不同类型的注释内容，注释的风格是不是统一？

有没有使用废弃的接口？

能不能替换掉废弃的接口？

不再推荐使用的接口，是否可以尽早废弃？

继承的方法，有没有使用 Override 注解？

有没有使用异常机制处理正常的业务逻辑？

异常类的使用是不是准确？

异常的描述是不是清晰？

是不是需要转换异常的场景？

转换异常场景，是不是需要保留原异常信息？

有没有不应该被吞噬的异常？

外部接口和内部实现有没有区分隔离？

接口规范描述是不是准确、清晰？

接口规范有没有描述返回值？

接口规范有没有描述运行时异常？

接口规范有没有描述检查型异常？

接口规范有没有描述指定参数范围？

接口规范有没有描述边界条件？

接口规范有没有描述极端状况？

接口规范的起草或者变更有没有通过审阅？

接口规范需不需要标明起始版本号？

产品设计是不是方便用户使用？

用户指南能不能快速上手？

用户指南的示例是不是可操作？

用户指南和软件代码是不是保持一致？

### 16丨代码“规范”篇用户答疑

《Unix 程序设计艺术》

《设计模式》

《Effective Java》

### 17 | 为什么需要经济的代码？

**需不需要“跑得快”的代码？**

*怎么理解代码的性能？*

代码的性能并不是可以多快地进行加减乘除，而是如何管理内存、磁盘、网络、内核等计算机资源。

事实上，代码的性能和算法密切相关，但是更重要的是，我们必须从架构层面来考虑性能，选择适当的技术架构和合适的算法。

*需不需要学习性能？*

编写经济的代码的门槛稍微高一些，它需要更多的知识和经验，但它也是能让我们脱颖而出的一个基本功。

需要我们解决的性能问题，很多时候都不是技术问题，而是意识和见识的问题。成熟的解决方案就在那儿，容易理解，也容易操作。只是，我们没有想到，没有看到，也没有用到这些解决方案。

*需不需要考虑代码性能？*

你真正需要关心的，是你的代码有多重要？代码带来的绝对价值越大，消耗的绝对成本越高，它的性能就越重要。

越早考虑性能问题，我们需要支付的成本就越小，带来的价值就越大。

**什么时候开始考虑性能问题？**

*硬件扩展能解决性能问题吗？*

出现性能问题，投入更多的设备，只是提高软件性能的一个特殊方法。而且，这不是一个廉价的方法。

硬件和性能的非线性关系，反而让代码的性能优化更有价值。

*性能问题能滞后处理吗？*

性能问题，有很多是架构性问题。一旦架构性问题出现，往往意味着代码要推倒重来，这可不是我们可以接受的快速迭代。

*要有性能工程的思维*

性能工程思维通过流程“左移”，把性能问题从一个一次性的测试行为，变成一个贯穿软件开发周期的持续性行为；从被动地接受问题审查，变成主动地管理质量。

### 18丨思考框架：什么样的代码才是高效的代码？

**用户的真实感受**

*等待时间要短*

根据任务的响应时间，应用程序性能指数定义了三个用户满意度的区间：

满意：如果任务的响应时间小于 T，用户感觉不到明显的阻碍，就会比较满意；

容忍：如果任务的响应时间大于 T，但是小于 F，用户能感觉到性能障碍，但是能够忍受，愿意等待任务的完成；

挫败：如果任务的响应时间大于 F 或者失败，用户就不会接受这样的等待。挫败感会导致用户放弃该任务。

在互联网领域，最佳等待时间（T）和最大可容忍等待时间（F）的选择有着非常经典的经验值，那就是最佳等待时间是 2 秒以内，最大可容忍等待时间是最佳等待时间的 4 倍，也就是 8 秒以内。

Apdex = (1 × 满意样本数 ＋ 0.5 × 容忍样本数 + 0 × 挫败样本数) / 样本总数

对于用户而言，打开一个网页就是一个完整的、不可分割的任务。

*体验要一致*

一个服务，如果 10 次访问有 2 次不满意，用户就很难对这个服务有一个很高的评价。

**代码的资源消耗**

*把资源使用得更有效率*

这个时候，就需要我们在这些计算机资源的使用上做出合理的选择和分配。

*能够使用好更多的资源*

当我们面对更多计算机资源的时候，能够用上它们、用好它们。

### 19 | 怎么避免过度设计？

**避免需求膨胀**

*识别最核心需求*

什么是必须做的？什么是现在就要做的？这是我们做选择时，要时刻准备提出和回答的两个问题。

我们的很多需求，来源于心里的推断，而不是眼前的事实。推断产生需求，催生的系统就会形成新的事实，强化推断的演进。

只有从最终用户的眼里看需求，才能够识别什么是最核心的需求，什么是衍生的需求，什么是无效的需求。

*不要一步到位（迭代演进）*

是不是迭代的时候，就可以考虑一些不重要的需求了呢？不，永远不要考虑不重要的需求。

**避免过度设计**

对软件来说，过度设计的接口意味着更多的代码、更多的维护、更多的修修补补，未来也不会节省我们的时间。

避免过度设计，和避免需求膨胀一样，我们要时刻准备提问和回答两个问题：什么是必须做的？什么是现在就必须做的？

### 20 | 简单和直观，是永恒的解决方案

**为什么需要简单直观？**

*简单直观是快速行动的唯一办法*

*简单直观减轻沟通成本*

*简单直观降低软件风险*

越复杂的软件，我们越难以理解，越难以实现，越难以测量，越难以实施，越难以维护，越难以推广。

**该怎么做到简单直观？**

*使用小的代码块*

为了保持代码块的简单，给代码分块的一个重要原则就是，一个代码块只做一件事情。

*遵守约定的惯例*

把代码块做小，背后隐含一个重要的假设：这些小代码块要容易组装。

而能够组装的代码，接口规范一定要清晰。越简单、越规范的代码块，越容易复用。

*花时间做设计*

一个优秀的程序员，可能 80% 的时间是在设计、拆解和验证，只有 20% 的时间是在写代码。

*借助有效的工具*

在拆解问题时，思维导图可以帮助我厘清思路，防止遗漏。时序图可以帮助我理解关键的用例，勾画清楚各个部件之间的联系。而问题清单，可以记录下要解决和已经解决的问题，帮助我记录状态、追踪进度。

### 21 | 怎么设计一个简单又直观的接口？

接口设计的困境，大多数来自于接口的稳定性要求。摆脱困境的有效办法不是太多，其中最有效的一个方法就是要保持接口的简单直观。

**从问题开始**

软件接口的设计，要从真实的问题开始。

面对要解决的问题，我们要把大问题分解成小问题，把小问题分解成更小的问题，直到呈现在我们眼前的是公认的事实或者是可以轻易验证的问题。

分解问题时，我们要注意分解的问题一定要“相互独立，完全穷尽”（Mutually Exclusive and Collectively Exhaustive）。这就是 MECE 原则。使用 MECE 原则，可以帮助我们用最高的条理化和最大的完善度理清思路。

*为什么从问题开始？*

从问题开始，是为了让我们能够找到一条主线。然后，围绕这条主线，去寻找解决问题的办法，而不是没有目标地让思维发散。这样，也可以避免需求膨胀和过度设计。

*自然而来的接口*

把大问题分解成小问题，再把小问题分解成更小的问题。在这个问题逐层分解的过程中，软件的接口以及接口之间的联系，也就自然而然地产生了。

我们在分解问题的过程中，涉及到的关键的动词和动词短语、名词和名词短语或者形容词，就是代码中类和方法的现实来源。

**一个接口一件事情**

*减少依赖关系*

这就要求我们弄清楚依赖关系，标明清楚依赖关系、调用顺序，以及异常行为。

*使用方式要“傻”*

方便、皮实的接口，才是好用的接口。接口要很容易理解，能轻易上手，这就是方便。此外还要限制少，怎么用都不容易出错，这就是皮实。

### 22 | 高效率，从超越线程同步开始！

**什么时候需要同步？**

使用两个以上的线程；关心共享资源的变化；改变共享资源的行为。

**避免线程同步**

使用单线程；不关心共享资源的变化；没有改变共享资源的行为。

我们要养成一个习惯，看到声明的变量，就要琢磨，这个变量能不能声明成不可变的量？现有的代码设计，这个变量如果不是不可变的，我们也要琢磨，有没有办法修改接口设计或者实现代码，把它改成不可变的量？设计一个类时，要优先考虑，这个类是不是可以设计成不可变的类？这样就可以避免很多不必要的线程同步，让代码的效率更高，接口更容易使用。

如果这是一个开放的不可变的类，我们要在接口规范里声明这个类是不可变的。这样调用者就不用考虑多线程安全的问题。

**减少线程同步时间**

减少阻塞时间的一个办法，就是只同步和共享资源变化相关的逻辑。引起共享资源变化的事前准备以及善后处理，属于线程内部变化，不需要同步处理。

在设计接口或者实现代码时，有一项很重要的工作，就是反复考虑在多线程环境下，怎么做才能让线程同步的阻塞时间最小。

### 23 | 怎么减少内存使用，减轻内存管理负担？

**减少实例数量**

对于数量有限的对象，我们应该优先考虑使用枚举类型，比如交通标志，国家名称等等。其实，枚举类型就是一种常用的数据静态化的范例。

*避免不必要的实例*

避免使用原始数据类型（primitive type）的构造方法，甚至避免使用这些类。

```java
String programingLanguage = new String("Java");
Boolean isEmpty = new Boolean(true);
Boolean isEmpty = new Boolean("true");
Boolean isEmpty = true;
```

*避免使用原始数据类*

Java 原始数据类型的自动装箱（boxing）与拆箱（unboxing）的类型转换。

*使用单实例模式*

**减小实例的尺寸**

第一个是尽量减少独占的空间；第二个是尽量使用共享的实例。

尽可能多地共享资源，这是一条提高效率的基本原则。在编写代码时，如果能够引用，就坚决不要拷贝；如果能够复用，就坚决不要新创。

有两类理想的共享资源，一类是一成不变（immutable）的资源，另一类是禁止修改（unmodifiable）的资源。

### 24 | 黑白灰，理解延迟分配的两面性

**延迟分配**

改动后的缺省构造方法，不再分配内部数组，而是使用了一个空数组。要等到真正需要存储数据的时候，才为这个数组分配空间。

```java
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

对于局部变量，我们应该坚持“需要时再声明，需要时再分配”的原则。

**延迟初始化**

这的确可以避免内存资源的浪费，但代价是要使用更多的 CPU。检查实例变量是否已经初始化，需要 CPU 的额外开销。

除非是静态变量，否则使用延迟初始化，一般也意味着放弃了使用不可变类的可能性。这就需要考虑线程安全的问题。

一般情况下，由于规范性带来的明显优势，我们优先使用“声明时就初始化”这个方案。

只有初始化占用的资源比较多或者占用的时间比较长的时候，我们才开始考虑其他的方案。复杂的方法，只有必要时才使用。

```java
public class CodingExample {
    private volatile Map<String, String> helloWordsMap;

    private void setHelloWord(String language, String greeting) {
        // 把共享的 volatile 变量的引用，赋值给一个局部的临时变量，然后使用临时变量进行操作，就起到了降低共享变量读写频率的效果
        Map<String, String> temporaryMap = helloWordsMap;
        if (temporaryMap == null) {
            synchronized (this) {
                temporaryMap = helloWordsMap;
                if (temporaryMap == null) {
                    temporaryMap = new ConcurrentHashMap<>();
                    helloWordsMap = temporaryMap;
                }
            }
        }
  
        temporaryMap.put(language, greeting);
    }
}
```

### 25 | 使用有序的代码，调动异步的事件

**为什么需要异步编程？**

为了更有效地利用计算资源，我们使用有序的代码，调动起独立的事件。

**从过程到事件**

异步编程和我们熟悉的同步编程最大的区别，就是它要我们从事件的角度来编写和理解代码。

指令发布完，这个语句的任务就完成了，就可以执行下一个语句了，不需要等待指令交代的任务完成。

**异步是怎么实现的？**

异步编程对性能的爆炸性的提升来自于硬件和操作系统对异步的支持。

异步 I/O

**零拷贝，进一步的性能提升**

ByteBuffer.allocateDirect()

### 26 | 有哪些招惹麻烦的性能陷阱？

**使用性能测试工具**

```bash
$ mvn archetype:generate \
    -DinteractiveMode=false \
    -DarchetypeGroupId=org.openjdk.jmh \
    -DarchetypeArtifactId=jmh-java-benchmark-archetype \
    -DgroupId=xyz.csongyu \
    -DartifactId=jmh \
    -Dversion=1.0.0
```

**字符串的操作**

String / StringBuffer / StringBuilder

`"Hello, " + "world!"` 这样的表达式，并没有真正执行字符串连接。编译器会把它处理成一个连接好的常量字符串 `"Hello, world!"`。这样，也就不存在反复的对象创建和销毁了。

```java
    // JMH throughput benchmark: about 21,000 operations per second
    @Benchmark
    public String measureStringBuilderApend() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            builder.append("hello");
        }

        return builder.toString();
    }
```

```java
    // JMH throughput benchmark: about 16,000 operations per second
    @Benchmark
    public String measureStringBuilderSynchronizedApend() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            synchronized (this) {
                builder.append("hello");
            }
        }

        return builder.toString();
    }
```

**内存的泄露**

静态的集合 / 长寿的缓存

SoftReference / WeakReference

**未关闭的资源**

原则上，所有实现了 Closable 接口的对象，都应该调用 close() 操作；所有需要明确关闭的类，都应该实现 Closable 接口。

需要注意的是，close() 操作，一定要使用 try-finally 或者 try-with-resource 语句。

**遗漏的 hashCode**

```java
    public static void main(final String[] args) {
        final Map<Key, String> map = new HashMap<>();
        for (int i = 0; i < 10; i++) {
            map.put(new Key("key"), "value");
        }
        System.out.println("map size: " + map.size());
    }

    private static class Key {
        private final String key;

        public Key(final String key) {
            this.key = key;
        }
    }
```

**撞车的哈希值**

哈希值如果相同，就要调用其他的方法来识别一个对象。

### 27 | 怎么编写可持续发展的代码？

规模扩张能力 / 功能扩展能力

**两种规模扩张方式**

规模垂直扩张 / 规模水平扩张

规模垂直扩张，指的是提高同一个处理单元处理更多负载的能力。

规模垂直扩张成本很高，而且是非线性的。

另外，规模垂直扩张是有上限的，一台服务器的处理能力不是可以无限扩展的。

规模水平扩张，指的是通过增加更多的处理单元，来处理更多的负载。

优秀的规模水平扩张技术，可以使用很多廉价的机器，提供大规模的计算能力。

**分离无状态数据**

独立的无状态数据服务，既没有规模水平扩张的羁绊，还能充分利用客户端的缓存。另外，无状态数据和状态数据的分离，可以集中资源处理状态数据，也能提高状态数据的处理能力。

**使用用户资源**

无状态服务，并不一定都没有服务状态。一个典型的做法是，服务端通过一定的数据保护机制，把服务状态保护起来，发送到客户端。然后，客户端缓存封印的服务状态。下次连接时，客户端把封印的服务状态原封不动地送回到服务端。然后，服务端解封客户端发送的封印服务状态，就获得了需要处理的状态数据。这样，既有了无状态服务的便利，解除了规模水平扩张的限制，又解决了服务需要状态的客观需求。

遗憾的是，这种设计能够提供的服务状态数据尺寸比较有限，应用场景也比较苛刻，而且数据保护机制一般也比较复杂。

### 28 | 怎么尽量“不写”代码？

商业的规模依赖于可复制性，代码的质量依赖于可复用性。

**不要重新发明轮子**

什么样的代码可以复用呢？一般来说，当我们使用类似的代码或者类似的功能超过两次时，就应该考虑这样的代码是不是可以复用了。

**推动轮子的改进**

如果发现轮子有问题，不要首先试图去重新发明一个相同的轮子，而是去改进它。

每一个可以复用的代码，特别是那些经过时间检验的接口，都踩过了很多坑，经过了多年的优化。如果我们试着重新编写一个相同的接口，一般意味着这些坑我们要重新考虑一遍，还不一定能够做得更好。

**该放手时就放手**

这些烂代码，如果运行得很好，没有出现明显的问题，我们就放手吧。

什么时候修改烂代码呢？代码投入使用之前，以及代码出问题的时候，就是我们修改烂代码的时候。

代码的修改都有哪些需要注意的地方呢？

代码规范方面的修改，可以大胆些。比如命名规范、代码整理，这些都动不了代码的逻辑，是安全的修改。

代码结构方面的修改，则要谨慎些，不要伤及代码的逻辑。比如把嵌套太多的循环拆分成多个方法，把几百行的代码拆分成不同的方法，把相似的代码抽象成复用的方法，这些也是相对安全的修改。

代码逻辑方面的修改，要特别小心，除了有明显的问题，我们都尽量避免修改代码的逻辑。

### 29 | 编写经济代码的检查清单

**需求评审**

需求是真实的客户需求吗？

要解决的问题真实存在吗？

需求具有普遍的意义吗？

这个需求到底有多重要？

需求能不能分解、简化？

需求的最小要求是什么？

这个需求能不能在下一个版本再实现？

**设计评审**

能使用现存的接口吗？

设计是不是简单、直观？

一个接口是不是只表示一件事情？

接口之间的依赖关系是不是明确？

接口的调用方式是不是方便、皮实？

接口的实现可以做到不可变吗？

接口是多线程安全的吗？

可以使用异步编程吗？

接口需不需要频繁地拷贝数据？

无状态数据和有状态数据需不需要分离？

有状态数据的处理是否支持规模水平扩张？

**代码评审**

有没有可以重用的代码？

新的代码是不是可以重用？

有没有使用不必要的实例？

原始数据类的使用是否恰当？

集合的操作是不是多线程安全？

集合是不是可以禁止修改？

实例的尺寸还有改进的空间吗？

需要使用延迟分配方案吗？

线程同步是不是必须的？

线程同步的阻塞时间可以更短吗？

多状态同步会不会引起死锁？

是不是可以避免频繁的对象创建、销毁？

是不是可以减少内存的分配、拷贝和释放频率？

静态的集合是否会造成内存泄漏？

长时间的缓存能不能及时清理？

系统的资源能不能安全地释放？

依赖哈希值的集合，储存的对象有没有实现 hashCode() 和 equals() 方法？

hashCode() 的实现，会不会产生撞车的哈希值？

代码的清理，有没有变更代码的逻辑？

### 30 | “代码经济篇”答疑汇总

**性能的监控、评测和分析**

第一个常用的工具是 JMH。特别是当我们面临两个选择，并且犹豫不决的时候，对比 JMH 的测试结果，就可以给我们提供一个大致准确的方向。

第二个常用的工具是性能回归测试。我们可以通过自动化的性能回归测试，来检测修改有没有恶化代码的性能。

第三个就是找一款成熟的性能调试工具，比如 NetBeans Profiler、JProfiler、Java Mission Control、Stackify Prefix 等。

第四个就是用实时的性能监控工具，比如 New Relic APM，Stackify Retrace 等。

**代码的尺寸**

在 JDK 9 中，Java 开始支持模块化（Java module）。Java 模块化背后的一个重要推动力量，就是 JDK 的尺寸。

**身份认证**

WebAuthn

### 31 | 为什么安全的代码这么重要？

**真正的威胁**

寻找并且通知受到安全漏洞影响的软件供应商，然后双方共同保密一段时间，给漏洞修复留出足够的时间，这是安全研究者的通常做法。

大部分有效的安全攻击，都是发生在漏洞公布之后，修复版本升级之前。这一段时间，是最危险的一段时间。

### 32 | 如何评估代码的安全缺陷？

**关注用户感受**

软件缺陷的定义方式和衡量方式有很多种。从用户感受的角度出发，定义和计量软件缺陷，是其中一个比较好的、常用的软件缺陷评估体系。我个人比较倾向一种观点，软件缺陷的严重程度应该和用户的痛苦程度成正比。

缺陷影响的深度（软件缺陷带来的问题的严重性） / 缺陷影响的广度（软件缺陷带来问题的可能性）

定义软件缺陷的优先等级：

高优先级（P1）：高严重性、高可能性；

中优先级（P2）：高严重性、低可能性；低严重性、高可能性；

低优先级（P3）：低严重性、低可能性。

**缺陷，需要从外向内看**

在一个好的软件缺陷评估体系中，不是只有代码错误才会被关注，没有错误的代码，也可能存在需要变更或者改进的“缺陷”。这就是我们要强调的，从用户的感受出发，定义和计量软件缺陷。

从用户视角出发的决策，可以让我们的时间使用得更有市场价值。

**优先级的灵活性**

软件缺陷优先等级的定义是为了帮助我们更好地解用户的感受程度，以及安排时间和处理事情。

实际工作中，我们有时候需要调节软件缺陷的优先等级，比如说：

如果已经存在应对办法，优先等级可以下调；

如果软件缺陷引起广泛的公开关注，优先等级应该上调；

如果软件缺陷影响了重要的客户，优先等级应该上调；

如果软件缺陷影响了重要的商业运营，优先等级应该上调。

**管理好自己的时间**

有什么事情是你必须要做的？

哪些事情是只有你能做的？

哪些事情是别人可以帮你做的？

**安全漏洞，需要大范围协作**

[CVSS](https://www.first.org/cvss/ "Common Vulnerability Scoring System")

对于安全缺陷的严重性，有四个互相独立的测量维度（量度）：

对私密性的影响（Confidentiality）

对完整性的影响（Integrity）

对可用性的影响（Availability）

对授权范围的影响（Authorization Scope）

对于安全缺陷的可能性，有四个互相独立的测量维度（量度）：

安全攻击的路径（Attack Vector）

安全攻击的复杂度（Attack Complexity）

安全攻击需要的授权（Privileges Required）

安全攻击是否需要用户参与（User Interaction）

[CVSS Version 3.0 Calculator](https://www.first.org/cvss/calculator/3.0)

**安全漏洞细节不可泄漏**

我们并不能总是预料到谁可以利用这些漏洞，以及由此带来的后果有多严重。

**安全漏洞要优先修复**

即使我们全力以赴地修复，在系统修复之前，安全攻击随时都有可能发生。我们能做的，就是尽最大努力，缩短这段时间。
